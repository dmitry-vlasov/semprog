import ds/tree;
import ds/set;
import string;

import types;
import term;

export {
    // General semantics: eval function.
    Eval(
        eval : (term : AlgTerm, vals : Tree<string, flow>) -> flow
    );
    Show(
        show : (term : AlgTerm) -> string
    );

    // The structure, which defines a sementics for an operation.
    EvalOper(
        name : string, 
        sign : TypeFunc, 
        sem  : (Eval, args : [AlgTerm], vals : Tree<string, flow>) -> flow,
        show : (Show, args : [AlgTerm]) -> string
    );

    makeSem(sem  : (Eval, args : [AlgTerm], vals : Tree<string, flow>) -> flow) -> (Eval) -> Eval;
    makeShow(show  : (Show, args : [AlgTerm]) -> string) -> (Show) -> Show;

    // Algebra: consists of a set of operations with their sementics.
    EvalAlgebra(name : string, opers : [EvalOper]);

    algebraEval(alg : EvalAlgebra) -> Eval;
    algebraShow(alg : EvalAlgebra) -> Show;

    // Show info about algebra, mainly its signature
    evalAlgebra2s(alg : EvalAlgebra) -> string;

    showDfEvalOper(name) -> (Show, args : [AlgTerm]) -> string;
    showConstEvalOper(name) -> (Show, args : [AlgTerm]) -> string;
    showUnaryEvalOper(name) -> (Show, args : [AlgTerm]) -> string;
    showBinaryEvalOper(name) -> (Show, args : [AlgTerm]) -> string;
    showBracketEvalOper(open : string, close : string, infix : string) -> (Show, args : [AlgTerm]) -> string;
    showNaryEvalOper(name : string, arity : int) -> (Show, args : [AlgTerm]) -> string;

    // Special constant: undefined value.
    UndefVal();
    undefVal = UndefVal();
    showValuation(v : Tree<string, flow>) -> string;
}

algebraEval(alg : EvalAlgebra) -> Eval {
    opers = fold(alg.opers, makeTree(), \acc, op -> setTree(acc, op.name, op));
    Eval(\term, vals -> evalAlgTerm(term, vals, opers));
}

evalAlgTerm(term : AlgTerm, vals : Tree<string, flow>, opers : Tree<string, EvalOper>) -> flow {
    eval = Eval(\t, vs -> evalAlgTerm(t, vs, opers));
    //println("eval of: " + term.name);
    switch (term) {
        AlgTermVar(name, type): {
            lookupTreeDef(vals, name, undefVal);
        }
        AlgTermFunc(name, args, type): {
            if (!containsKeyTree(opers, name)) {
                println("unknown operator: " + name);
            }
            eitherMap(lookupTree(opers, name), \op -> op.sem(eval, args, vals), undefVal);
        }
    }
}

algebraShow(alg : EvalAlgebra) -> Show {
    opers = fold(alg.opers, makeTree(), \acc, op -> setTree(acc, op.name, op));
    Show(\term -> showAlgTerm(term, opers));
}

showAlgTerm(term : AlgTerm, opers : Tree<string, EvalOper>) -> string {
    show = Show(\t, -> showAlgTerm(t, opers));
    switch (term) {
        AlgTermVar(name, type): name;
        AlgTermFunc(name, args, type): {
            if (!containsKeyTree(opers, name)) {
                println("unknown operator: " + name);
            }
            eitherMap(lookupTree(opers, name), \op -> op.show(show, args), "undefVal");
        }
    }
}

evalAlgebra2s(alg : EvalAlgebra) -> string {
    "Algebra " + alg.name + ":\n"+ 
    strGlue(map(alg.opers, \op -> "\t" + op.name + " : " + type2s(op.sign) + "\n"),  "");
}

showDfEvalOper(name : string) -> (Show, args : [AlgTerm]) -> string {
    \s, args -> {
        name + (if (length(args) == 0) "" else  "(" + strGlue(map(args, \a -> s.show(a)), ", ") + ")");
    }
}

showConstEvalOper(name : string) -> (Show, args : [AlgTerm]) -> string {
    \s, args -> if (length(args) != 0) "broken AlgTerm" else name;
}

showUnaryEvalOper(name : string) -> (Show, args : [AlgTerm]) -> string {
    \s, args -> {
        if (length(args) != 1) "broken AlgTerm" else
            name + s.show(args[0]);
    }
}

showBinaryEvalOper(name : string) -> (Show, args : [AlgTerm]) -> string {
    \s, args -> {
        if (length(args) != 2) "broken AlgTerm" else
        "(" + s.show(args[0]) + " " + name + " " + s.show(args[1]) + ")";
    }
}

showNaryEvalOper(name : string, arity : int) -> (Show, args : [AlgTerm]) -> string {
    \s, args -> {
        if (length(args) != arity) "broken AlgTerm" else
        "(" + strGlue(map(args, \arg -> s.show(arg)), " " + name + " ")  + ")";
    }
}

showBracketEvalOper(open : string, close : string, infix : string) -> (Show, args : [AlgTerm]) -> string {
    \s, args -> open + strGlue(map(args, \a -> s.show(a)), infix + " ") + close;
}

showValuation(v : Tree<string, flow>) -> string {
    strGlue(map(tree2pairs(v), \p -> p.first + "=" + toString(p.second)),  ", ");
}

// Experimental

makeSem(sem  : (Eval, args : [AlgTerm], vals : Tree<string, flow>) -> flow) -> (Eval) -> Eval {
    \e -> Eval(\t, vs -> 
        switch (t) {
            AlgTermVar(v, __): lookupTreeDef(vs, v, undefVal);
            AlgTermFunc(__, args, __): sem(e, args, vs);
        }
    );
}
makeShow(show  : (Show, args : [AlgTerm]) -> string) -> (Show) -> Show {
    \s -> Show(\t ->
        switch (t) {
            AlgTermVar(v, __): v;
            AlgTermFunc(__, args, __): show(s, args);
        }
    );
}