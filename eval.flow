import conf;
import type;
import term;
import common_types;

export {
    // General semantics: eval function.
    Eval(
        eval : (vals : Tree<string, flow>, conf : Conf) -> flow
    );
    Show(
        show : () -> string
    );

    // The structure, which defines a sementics for an operation.
    // Operation may be polymorphic, i.e. may deal on different types of arguments.
    EvalOper(
        name : string, 
        sign : AlgTypeFunc, 
        eval : (args : [Eval]) -> Eval,
        show : (args : [Show]) -> Show
    );

    // A constant provider. When a constant of a certain type is met,
    // this structure provides its value from a string representation.
    EvalConst(
        type : AlgTypeFunc,
        eval : (string, Conf) -> flow
     );

    // Algebra: consists of a set of operations with their sementics.
    EvalAlgebra(name : string, opers : [EvalOper], consts : [EvalConst]);

    algebraEval(alg : EvalAlgebra) -> (AlgTerm) -> Eval;
    algebraShow(alg : EvalAlgebra) -> (AlgTerm) -> Show;

    // Show info about algebra, mainly its signature
    evalAlgebra2s(alg : EvalAlgebra) -> string;

    showDfEvalOper(name : string) -> (args : [Show]) -> Show;
    showConstEvalOper(name : string) -> (args : [Show]) -> Show;
    showUnaryEvalOper(name) -> (args : [Show]) -> Show;
    showBinaryEvalOper(name) -> (args : [Show]) -> Show;
    showBracketEvalOper(open : string, close : string, infix : string) -> (args : [Show]) -> Show;
    showNaryEvalOper(name : string, arity : int) -> (args : [Show]) -> Show;
    showVariadicEvalOper(name : string) -> (args : [Show]) -> Show;

    // Special constant: undefined value.
    UndefVal();
    undefVal = UndefVal();
    showValuation(v : Tree<string, flow>) -> string;

    evalArgs(args : [Eval], vals : Tree<string, flow>, conf : Conf) -> [flow];
}

algebraEval(alg : EvalAlgebra) -> (AlgTerm) -> Eval {
    opers = fold(alg.opers, makeTree(), \acc, op -> 
        setTree(acc, op.name, concat(lookupTreeDef(acc, op.name, []), [op]))
    );
    consts = fold(alg.consts, makeTree(), \acc, const -> {
        if (containsKeyTree(acc, const.type)) {
            println("constant provider for type " + algType2s(const.type) + " is already provided");
        }
        setTree(acc, const.type, const);
    });
    \term -> evalAlgTerm(term, opers, consts);
}

forall_quant =  EvalOper("Forall",
        funcAlgType([stringType, arrayAlgType(AlgTypeVar("T")), boolType] , boolType),
        \args -> {
            Eval(\vals, conf -> {
                if (length(args) != 3) {
                    flow(undefVal)
                } else {
                    v = flow2s(args[0].eval(vals, conf));
                    flow(forall(
                        cast(args[1].eval(vals, conf) : flow -> [?]),
                        \a -> flow2b(args[2].eval(setTree(vals, v, a), conf))
                    ));
                }
            })
        },
        \args -> Show(\-> 
            if (length(args) != 3) "broken term" else
            "Forall " + args[0].show() + " : " + args[1].show() + " " + args[2].show()
        )
    ); 

evalAlgTerm(
    term : AlgTerm,
    opers : Tree<string, [EvalOper]>,
    consts : Tree<AlgTypeFunc, EvalConst>
) -> Eval {
    switch (term) {
        AlgTermVar(name, type): {
            Eval(\vals, conf -> {
                val = lookupTreeDef(vals, name, flow(undefVal));
                if (conf.trace) {
                    println(strIndentMany("var " + name + " = " + toString(val), ^(conf.callDepth)));
                }
                val;
            });
        }
        AlgTermVarDecl(name, __): {
            Eval(\vals, conf -> {
                flow(name);
            });
        }
        AlgTermFunc(name, args, type): {
            arg_types = map(args, \arg -> arg.type);
            eitherMap(lookupTree(opers, name), 
                \ops -> {
                    fits = filter(ops, \op -> 
                        isSome(matchTypes(funcArgTypes(op.sign), arg_types, makeTree()))
                    );
                    if (length(fits) == 0) {
                        println(
                            "No operator " + name + " matches argument types: [" + 
                            strGlue(map(arg_types, \t -> algType2s(t)), ", ") + "]"
                        );
                        flow(undefVal);
                    } else if (length(fits) > 1) {
                        println(
                            "Ambigous operator " + name + " matching with argument types: [" + 
                            strGlue(map(arg_types, \t -> algType2s(t)), ", ") + "]"
                        );
                        flow(undefVal);
                    } else {
                        //call_depth = ^(conf.callDepth);
                        //conf.callDepth := call_depth + 1;
                        eval = fits[0].eval(map(args, \arg -> evalAlgTerm(arg, opers, consts)));
                        //conf.callDepth := call_depth;
                        Eval(\vals, conf -> {
                            if (conf.trace) {
                                println(strIndentMany("applying " + name, ^(conf.callDepth)));
                            }
                            eval.eval(vals, conf);
                        });
                    }
                }, 
                if (length(args) != 0) {
                    if (!containsKeyTree(opers, name)) {
                       println("Unknown operator: " + name);
                    }
                    Eval(\vals, conf -> {
                        flow(undefVal)
                    });
                } else {
                    switch (lookupTree(consts, type)) {
                        Some(const): {
                            Eval(\vals, conf -> {
                                if (conf.trace) {
                                   println(strIndentMany("const: " + name, ^(conf.callDepth)));
                                }
                                flow(const.eval(name, conf));
                            });
                        }
                        None(): {
                            println("Constant: " + name + " of type " + toString(type) +  " is uniterpreted");
                            Eval(\vals, conf -> flow(undefVal));
                        }
                    }
                }
            );
        }
    }
}

algebraShow(alg : EvalAlgebra) -> (AlgTerm) -> Show {
    opers = fold(alg.opers, makeTree(), \acc, op -> 
        setTree(acc, op.name, concat(lookupTreeDef(acc, op.name, []), [op]))
    );
    consts = fold(alg.consts, makeTree(), \acc, const -> {
        if (containsKeyTree(acc, const.type)) {
            println("constant provider for type " + algType2s(const.type) + " is already provided");
        }
        setTree(acc, const.type, const);
    });
    \term -> showAlgTerm(term, opers, consts);
}

showAlgTerm(
    term : AlgTerm, 
    opers : Tree<string, [EvalOper]>,
    consts : Tree<AlgTypeFunc, EvalConst>
) -> Show {
    switch (term) {
        AlgTermVar(name, type): Show(\-> name);
        AlgTermVarDecl(name, type): Show(\-> name + " : " + algType2s(type));
        AlgTermFunc(name, args, type): {
            arg_types = map(args, \arg -> arg.type);
            eitherMap(
                lookupTree(opers, name), 
                \ops -> {
                    fits = filter(ops, \op -> 
                        isSome(matchTypes(funcArgTypes(op.sign), arg_types, makeTree()))
                    );
                    if (length(fits) == 0) {
                        println("No operator " + name + " matches argument types: " + strGlue(map(arg_types, \t -> algType2s(t)), ", "));
                        println("ops: " + strGlue(map(ops, \op -> algType2s(op.sign)), ", "));
                        Show(\-> "undefVal");
                    } else if (length(fits) > 1) {
                        println("Ambigous operator " + name + " matching with argument types: " + strGlue(map(arg_types, \t -> algType2s(t)), ", "));
                        Show(\-> "undefVal");
                    } else {
                        op = fits[0];
                        op.show(map(args, \arg -> showAlgTerm(arg, opers, consts)));
                    }
                }, 
                if (length(args) != 0) {
                    Show(\-> name + "(" + strGlue(map(args, \arg -> showAlgTerm(arg, opers, consts).show()), ", ") + ")");
                } else {
                    Show(\-> name);
                    /*switch (lookupTree(consts, type)) {
                        Some(__): name;
                        None(): {
                            println("constant: " + name + " of type " + toString(type) +  " is uniterpreted");
                            "undefVal"
                        }
                    }*/
                }
            );
        }
    }
}

evalAlgebra2s(alg : EvalAlgebra) -> string {
    alg.name + ":\n"+ 
    strGlue(map(alg.opers, \op -> "\t" + op.name + " : " + algType2s(op.sign) + "\n"),  "") +
    (if (length(alg.consts) == 0) "" else 
        "\n" + 
        strGlue(map(alg.consts, \const -> "\tconst (string) -> " + algType2s(const.type) + "\n"), "")
    );
}

showValuation(v : Tree<string, flow>) -> string {
    strGlue(map(tree2pairs(v), \p -> p.first + "=" + toString(p.second)),  ", ");
}


showDfEvalOper(name : string) ->  (args : [Show]) -> Show {
    \args -> Show(\->
        name + (if (length(args) == 0) "" else  "(" + strGlue(map(args, \arg -> arg.show()), ", ") + ")")
    );
}

showConstEvalOper(name : string) ->  (args : [Show]) -> Show {
    \args -> Show(\->
        if (length(args) != 0) "broken const " + name + ", args: [" + strGlue(map(args, \arg -> arg.show()), ", ") + "]" else name
    );
}

showUnaryEvalOper(name : string) -> (args : [Show]) -> Show {
    \args -> Show(\->
        if (length(args) != 1) "broken unary " + name + ", args: [" + strGlue(map(args, \arg -> arg.show()), ", ") + "]" 
        else name + args[0].show()
    );
}

showBinaryEvalOper(name : string) -> (args : [Show]) -> Show {
    \args -> Show(\->
        if (length(args) != 2) "broken binary " + name + ", args: [" + strGlue(map(args, \arg -> arg.show()), ", ") + "]"  else
        "(" + args[0].show() + " " + name + " " + args[1].show() + ")"
    );
}

showNaryEvalOper(name : string, arity : int) ->  (args : [Show]) -> Show {
    \args -> Show(\->
        if (length(args) != arity) "broken " + i2s(arity) + "-ary " + name + ", args: [" + strGlue(map(args, \arg -> arg.show()), ", ") + "]" else
        "(" + strGlue(map(args, \arg -> arg.show()), " " + name + " ")  + ")"
    );
}

showVariadicEvalOper(name : string) ->  (args : [Show]) -> Show {
    \args -> Show(\->
        "(" + strGlue(map(args, \arg -> arg.show()), " " + name + " ")  + ")"
    );
}

showBracketEvalOper(open : string, close : string, infix : string) ->  (args : [Show]) -> Show {
    \args -> Show(\->
        open + strGlue(map(args, \arg -> arg.show()), infix + " ") + close
    );
}

evalArgs(args : [Eval], vals : Tree<string, flow>, conf : Conf) -> [flow] {
    map(args, \arg -> arg.eval(vals, conf));
}