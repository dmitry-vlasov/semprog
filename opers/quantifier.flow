import eval;
import dynamic;
import opers/string;

export {
    // Basic first order logic construcitons: restricted quantifier, equality and predicates.
    makeQuantifier(Q : string, quant : ([?], (?) -> bool) -> bool) -> EvalOper;
    makeListQuantifier(Q : string, quant : ([[?]], ([?]) -> bool) -> bool) -> EvalOper;
    makePredicate(name : string, types : [AlgType], p : ([flow]) -> bool) -> EvalOper;

    folOpers : [EvalOper];

    makeForallTerm(v : AlgTermVarUse, t : AlgTerm, phi : AlgTerm) -> AlgTermFunc;
    makeExistsTerm(v : AlgTermVarUse, t : AlgTerm, phi : AlgTerm) -> AlgTermFunc;

    algTerm2freeVars(t : AlgTerm) -> Set<AlgTermVarUse>;
    algTerm2boundVars(t : AlgTerm) -> Set<AlgTermVarUse>;
    algTermCountBoundVars(t : AlgTerm) -> Tree<AlgTermVarUse, int>;
}

folOpers = [
    EvalOper("=", 
        funcAlgType([AlgTypeVar("T"), AlgTypeVar("T")] , boolType),
        \args -> Eval(\vals, conf ->
            if (length(args) != 2) flow(undefVal) else {
                flow(args[0].eval(vals, conf) == args[1].eval(vals, conf));
            }
        ),
        showBinaryEvalOper("=")
    ),
    EvalOper("!=", 
        funcAlgType([AlgTypeVar("T"), AlgTypeVar("T")] , boolType),
        \args -> Eval(\vals, conf ->
            if (length(args) != 2) flow(undefVal) else {
                flow(args[0].eval(vals, conf) != args[1].eval(vals, conf));
            }
        ),
        showBinaryEvalOper("!=")
    ),
    EvalOper("F",
        funcAlgType(
            [AlgTypeVar("T"), arrayAlgType(AlgTypeVar("T")), boolType] , 
            arrayAlgType(AlgTypeVar("T"))
        ),
        \args -> Eval(\vals, conf ->
            if (length(args) != 3) {
                flow(undefVal)
            } else {
                v = flow2s(args[0].eval(vals, conf));
                flow(filter(
                    cast(args[1].eval(vals, conf) : flow -> [flow]),
                    \a -> flow2b(args[2].eval(setTree(vals, v, a), conf))
                ));
            }
        ),
        \args -> Show(\conf ->
            if (length(args) != 3) "broken term" else {
            	long = "F " + args[0].show(conf) + " in " + args[1].show(conf) + " " + args[2].show(conf);
				if (strlen(long) <= conf.foldLen) long else {
					"F " + args[0].show(conf) + " in " + args[1].show(conf) + "\n" + strIndent(args[2].show(conf));
				}
			}
        )
    ),
    EvalOper("SF",
        funcAlgType(
            [AlgTypeVar("T"), arrayAlgType(AlgTypeVar("T")), boolType] , 
            arrayAlgType(AlgTypeVar("T"))
        ),
        \args -> Eval(\vals, conf ->
            if (length(args) != 3) {
                flow(undefVal)
            } else {
                v = flow2s(args[0].eval(vals, conf));
                a = cast(args[1].eval(vals, conf) : flow -> [flow]);
                sublists = map(enumFromTo(0, length(a)), \l -> subrange(a, 0, l));
                flow(filter(
                    sublists,
                    \sl -> flow2b(args[2].eval(setTree(vals, v, sl), conf))
                ));
            }
        ),
        \args -> Show(\conf -> 
            if (length(args) != 3) "broken term" else {
            	long = "SF " + args[0].show(conf) + " in " + args[1].show(conf) + " " + args[2].show(conf);
				if (strlen(long) <= conf.foldLen) long else {
					"SF " + args[0].show(conf) + " in " + args[1].show(conf) + "\n" + strIndent(args[2].show(conf));
				}
			}
        )
    ),
    makeQuantifier("A", forall),
    makeQuantifier("E", exists),
    makeListQuantifier("SA", forall),
    makeListQuantifier("SE", exists),
    makePredicate("in", 
        [AlgTypeVar("T"), arrayAlgType(AlgTypeVar("T"))], 
        \args -> {
            if (args[0] == undefVal || args[1] == undefVal) flow(undefVal) else {
                x = args[0];
                a = cast(args[1] : flow -> [flow]);
                flow(exists(a, \y -> y == x));
            }
        }
    ),
    makePredicate("sub", 
        [arrayAlgType(AlgTypeVar("T")), arrayAlgType(AlgTypeVar("T"))], 
        \args -> {
            a1 = cast(args[0] : flow -> [flow]);
            a2 = cast(args[1] : flow -> [flow]);
            if (length(a1) > length(a2)) false else 
            forall(zipWith(a1, a2, \x1, x2 -> Pair(x1, x2)), \p -> p.first == p.second);
        }
    ),
    makePredicate("<", [intType, intType], \args -> flow2i(args[0]) < flow2i(args[1])),
    makePredicate("<=", [intType, intType], \args -> flow2i(args[0]) <= flow2i(args[1])),
    EvalOper(
        "if", 
        funcAlgType([boolType, AlgTypeVar("T"), AlgTypeVar("T")], AlgTypeVar("T")),
        \args -> Eval(\vals, conf ->
            if (length(args) != 3) flow(undefVal) else {
                if (flow2b(args[0].eval(vals, conf))) {
                    args[1].eval(vals, conf);
                } else {
                    args[2].eval(vals, conf);
                }
            }
        ),
        \args -> Show(\conf ->
            if (length(args) != 3) "broken term" else {
            	long = "(if " + args[0].show(conf) + " then " + args[1].show(conf) + " else " + args[2].show(conf) + ")";
				if (strlen(long) <= conf.foldLen) long else {
					"(if " + args[0].show(conf) + " then\n" + strIndent(args[1].show(conf)) + "\nelse\n" + strIndent(args[2].show(conf)) + "\n)";
				}
			}
        )
    ),
    EvalOper(
        "?", 
        funcAlgType([boolType, AlgTypeVar("T"), AlgTypeVar("T")], AlgTypeVar("T")),
        \args -> Eval(\vals, conf ->
            if (length(args) != 3) flow(undefVal) else {
                cond = args[0].eval(vals, conf);
                if (flow2b(cond)) {
                    args[1].eval(vals, conf);
                } else {
                    args[2].eval(vals, conf);
                }
            }
        ),
        \args -> Show(\conf ->
            if (length(args) != 3) "broken term" else {
            	long = "(" + args[0].show(conf) + " ? " + args[1].show(conf) + " : " + args[2].show(conf) + ")";
				if (strlen(long) <= conf.foldLen) long else {
					"(\n" + strIndent(args[0].show(conf)) + " ?\n" + strIndent(args[1].show(conf)) + " :\n" + strIndent(args[2].show(conf)) + "\n)"
				}
			}
        )
    ),
    EvalOper(
        "lambda0", 
        funcAlgType([AlgTypeVar("V")], funcAlgType([], AlgTypeVar("V"))),
        \args -> Eval(\vals, conf -> {
            flow(\-> args[0].eval(vals, conf));
        }),
        \args -> Show(\conf -> {
			long = "lambda0 " + args[0].show(conf);
			if (strlen(long) <= conf.foldLen) long else {
				"lambda0\n" + strIndent(args[0].show(conf));
			}
		})
    ),
	EvalOper(
        "lambda1", 
        funcAlgType([AlgTypeVar("A"), AlgTypeVar("V")], funcAlgType([AlgTypeVar("A")], AlgTypeVar("V"))),
        \args -> Eval(\vals, conf -> {
            v = flow2s(args[0].eval(vals, conf));
            flow(\x -> args[1].eval(setTree(vals, v, x), conf));
        }),
        \args -> Show(\conf -> {
            long = "lambda1 " + args[0].show(conf) + " " + args[1].show(conf);
			if (strlen(long) <= conf.foldLen) long else {
				"lambda1 " + args[0].show(conf) + "\n" + strIndent(args[1].show(conf));
			}
		})
    ),
	EvalOper(
        "lambda2", 
        funcAlgType(
			[AlgTypeVar("A1"), AlgTypeVar("A2"), AlgTypeVar("V")], 
			funcAlgType([AlgTypeVar("A1"), AlgTypeVar("A2")], AlgTypeVar("V"))
		),
        \args -> Eval(\vals, conf -> {
            v1 = flow2s(args[0].eval(vals, conf));
			v2 = flow2s(args[1].eval(vals, conf));
            flow(\x, y -> args[2].eval(setTree(setTree(vals, v1, x), v2, y), conf));
        }),
        \args -> Show(\conf -> {
            long = "lambda2 " + args[0].show(conf) + ", " + args[1].show(conf) + " " + args[2].show(conf);
			if (strlen(long) <= conf.foldLen) long else {
				"lambda2 " + args[0].show(conf) + ", " + args[1].show(conf) + "\n" + strIndent(args[2].show(conf));
			}
		})
    ),
	EvalOper(
        "lambda3", 
        funcAlgType(
			[AlgTypeVar("A1"), AlgTypeVar("A2"), AlgTypeVar("A3"), AlgTypeVar("V")], 
			funcAlgType([AlgTypeVar("A1"), AlgTypeVar("A2"), AlgTypeVar("A3")], AlgTypeVar("V"))
		),
        \args -> Eval(\vals, conf -> {
            v1 = flow2s(args[0].eval(vals, conf));
			v2 = flow2s(args[1].eval(vals, conf));
			v3 = flow2s(args[2].eval(vals, conf));
            flow(\x, y, z -> args[3].eval(setTree(setTree(setTree(vals, v1, x), v2, y), v3, z), conf));
        }),
        \args -> Show(\conf -> {
            long = "lambda3 " + args[0].show(conf) + ", " + args[1].show(conf) + ", " + args[2].show(conf) + " " + args[3].show(conf);
			if (strlen(long) <= conf.foldLen) long else {
				"lambda3 " + args[0].show(conf) + ", " + args[1].show(conf) + ", " + args[2].show(conf) + "\n" + strIndent(args[3].show(conf));
			}
		})
    ),
	EvalOper(
        "call0", 
        funcAlgType(
			[funcAlgType([], AlgTypeVar("V"))], 
			AlgTypeVar("V")
		),
        \args -> Eval(\vals, conf -> {
            fn = cast(args[0].eval(vals, conf) : flow -> () -> flow);
            fn();
        }),
        \args -> Show(\conf -> {
			long = "call0(" + args[0].show(conf) + ")";
			if (strlen(long) <= conf.foldLen) long else {
				"call0(\n" + strIndent(args[0].show(conf)) + "\n)";
			}
		})
    ),
    EvalOper(
        "call1", 
        funcAlgType(
			[
				funcAlgType([AlgTypeVar("A")], AlgTypeVar("V")), 
				AlgTypeVar("A")
			], 
			AlgTypeVar("V")
		),
        \args -> Eval(\vals, conf -> {
            fn = cast(args[0].eval(vals, conf) : flow -> (flow) -> flow);
            ar = args[1].eval(vals, conf);
            fn(ar);
        }),
        \args -> Show(\conf -> {
            long = "call1(" + args[0].show(conf) + ", " + args[1].show(conf) + ")";
			if (strlen(long) <= conf.foldLen) long else {
				"call1(\n" + 
					strIndent(args[0].show(conf)) + ",\n" + 
					strIndent(args[1].show(conf)) + 
				"\n)";
			}
		})
    ),
	EvalOper(
        "call2", 
        funcAlgType(
			[
				funcAlgType([AlgTypeVar("A1"), AlgTypeVar("A2")], AlgTypeVar("V")), 
				AlgTypeVar("A1"), AlgTypeVar("A2")
			], 
			AlgTypeVar("V")
		),
        \args -> Eval(\vals, conf -> {
            fn = cast(args[0].eval(vals, conf) : flow -> (flow, flow) -> flow);
            a_1 = args[1].eval(vals, conf);
			a_2 = args[2].eval(vals, conf);
            fn(a_1, a_2);
        }),
        \args -> Show(\conf -> {
            long = "call2(" + args[0].show(conf) + ", " + args[1].show(conf) + ", " + args[2].show(conf) + ")";
			if (strlen(long) <= conf.foldLen) long else {
				"call2(\n" + 
					strIndent(args[0].show(conf)) + ",\n" + 
					strIndent(args[1].show(conf)) + ",\n" + 
					strIndent(args[2].show(conf)) + 
				"\n)";
			}
		})
    ),
	EvalOper(
        "call3", 
        funcAlgType(
			[
				funcAlgType([AlgTypeVar("A1"), AlgTypeVar("A2"), AlgTypeVar("A3")], AlgTypeVar("V")), 
				AlgTypeVar("A1"), AlgTypeVar("A2"), AlgTypeVar("A3")
			], 
			AlgTypeVar("V")
		),
        \args -> Eval(\vals, conf -> {
            fn = cast(args[0].eval(vals, conf) : flow -> (flow, flow, flow) -> flow);
            a_1 = args[1].eval(vals, conf);
			a_2 = args[2].eval(vals, conf);
			a_3 = args[3].eval(vals, conf);
            fn(a_1, a_2, a_3);
        }),
        \args -> Show(\conf -> {
            long = "call3(" + args[0].show(conf) + ", " + args[1].show(conf) + ", " + args[2].show(conf) + ", " + args[3].show(conf) + ")";
			if (strlen(long) <= conf.foldLen) long else {
				"call3(\n" + 
					strIndent(args[0].show(conf)) + ",\n" + 
					strIndent(args[1].show(conf)) + ",\n" + 
					strIndent(args[2].show(conf)) + ",\n" + 
					strIndent(args[3].show(conf)) + 
				"\n)";
			}
		})
    ),
	EvalOper(
        "rec1", 
        funcAlgType(
			[funcAlgType([AlgTypeVar("A1"), AlgTypeVar("A2"), AlgTypeVar("A3")], AlgTypeVar("V"))], 
			funcAlgType([AlgTypeVar("A1")], AlgTypeVar("V"))
		),
        \args -> Eval(\vals, conf -> {
            fn = args[0].eval(vals, conf);
			flow(\n -> 
				cast(fn : flow -> ((flow, flow, flow) -> flow))(n, 1, fn)
			);
        }),
        \args -> Show(\conf -> {
            long = "rec1(" + args[0].show(conf) + ")";
			if (strlen(long) <= conf.foldLen) long else {
				"rec1(\n" + strIndent(args[0].show(conf)) + "\n)";
			}
		})
    ),
	EvalOper(
        "let", 
        funcAlgType([AlgTypeVar("A"), AlgTypeVar("A"), AlgTypeVar("V")], AlgTypeVar("V")),
        \args -> Eval(\vals, conf -> {
            v = flow2s(args[0].eval(vals, conf));
			def = args[1].eval(vals, conf);
            args[2].eval(setTree(vals, v, def), conf);
        }),
        \args -> Show(\conf -> {
            long = "let " + args[0].show(conf) + " = " + args[1].show(conf) + "; " + args[2].show(conf);
			if (strlen(long) <= conf.foldLen) long else {
				"let " + args[0].show(conf) + " = " + args[1].show(conf) + ";\n" + args[2].show(conf);
			}
		})
    ),
];

makeQuantifier(Q : string, quant : ([?], (?) -> bool) -> bool) -> EvalOper {
    EvalOper(Q,
        funcAlgType([AlgTypeVar("T"), arrayAlgType(AlgTypeVar("T")), boolType] , boolType),
        \args -> Eval(\vals, conf ->
            if (length(args) != 3) {
                flow(undefVal)
            } else {
                v = flow2s(args[0].eval(vals, conf));
                flow(quant(
                    cast(args[1].eval(vals, conf) : flow -> [?]),
                    \a -> flow2b(args[2].eval(setTree(vals, v, a), conf))
                ));
            }
        ),
        \args -> Show(\conf -> 
            if (length(args) != 3) "broken term" else {
            	long = Q + " " + args[0].show(conf) + " in " + args[1].show(conf) + " " + args[2].show(conf);
				if (strlen(long) < conf.foldLen) long else {
					Q + " " + args[0].show(conf) + " in " + args[1].show(conf) + "\n" + strIndent(args[2].show(conf));
				}
			}
		)
    ); 
}

makeListQuantifier(Q : string, quant : ([[?]], ([?]) -> bool) -> bool) -> EvalOper {
    EvalOper(Q,
        funcAlgType([AlgTypeVar("T"), arrayAlgType(AlgTypeVar("T")), boolType] , boolType),
        \args -> Eval(\vals, conf -> 
            if (length(args) != 3) {
                flow(undefVal)
            } else {
                v = flow2s(args[0].eval(vals, conf));
                a = cast(args[1].eval(vals, conf) : flow -> [flow]);
                sublists = map(enumFromTo(0, length(a)), \l -> subrange(a, 0, l));
                flow(quant(
                    sublists,
                    \sl -> flow2b(args[2].eval(setTree(vals, v, sl), conf))
                ));
            }
        ),
        \args -> Show(\conf ->
            if (length(args) != 3) "broken term" else {
            	long = Q + " " + args[0].show(conf) + " in " + args[1].show(conf) + " " + args[2].show(conf);
				if (strlen(long) < conf.foldLen) long else {
					Q + " " + args[0].show(conf) + " in " + args[1].show(conf) + "\n" + strIndent(args[2].show(conf));
				}
			}
        )
    ); 
}

makePredicate(name : string, types : [AlgType], p : ([flow]) -> bool) -> EvalOper {
    EvalOper(name, 
        funcAlgType(types, boolType),
        \args -> Eval(\vals, conf ->
            if (length(args) != length(types)) flow(undefVal) else {
                flow(p(evalArgs(args, vals, conf)))
            }
        ),
        showDfEvalOper(name)
    );
}

makeForallTerm(v : AlgTermVarUse, t : AlgTerm, phi : AlgTerm) -> AlgTermFunc {
    AlgTermFunc("A", [AlgTermFunc(v.name, [], stringType), t, phi], boolType);
}

makeExistsTerm(v : AlgTermVarUse, t : AlgTerm, phi : AlgTerm) -> AlgTermFunc {
    AlgTermFunc("E", [AlgTermFunc(v.name, [], stringType), t, phi], boolType);
}

algTerm2freeVars(t : AlgTerm) -> Set<AlgTermVarUse> {
    doAlgTerm2freeVars(makeSet(), t);
}

doAlgTerm2freeVars(acc : Set<AlgTermVarUse>, t : AlgTerm) -> Set<AlgTermVarUse> {
    switch (t) {
        AlgTermVarUse(__,__): insertSet(acc, t);
        AlgTermVarDecl(__,__): acc;
        AlgTermFunc(name, args, __): {
            acc1 = fold(args, acc, doAlgTerm2freeVars);
            if (!isVarBounderOper(name)) acc1 else {
                removeSet(acc1, cast(args[0] : AlgTerm -> AlgTermVarUse));
            }
        }
    }
}

algTerm2boundVars(t : AlgTerm) -> Set<AlgTermVarUse> {
    free = algTerm2freeVars(t);
    all = algTerm2vars(t);
    differenceSets(all, free);
}

algTermCountBoundVars(t : AlgTerm) -> Tree<AlgTermVarUse, int> {
    doAlgTermCountBoundVars(makeTree(), t);
}

doAlgTermCountBoundVars(acc : Tree<AlgTermVarUse, int>, t : AlgTerm) -> Tree<AlgTermVarUse, int> {
    switch (t) {
        AlgTermVarUse(__,__): acc; // setTree(acc, t, lookupTreeDef(acc, t, 0) + 1);
        AlgTermVarDecl(__,__): acc; 
        AlgTermFunc(name, args, __): {
            acc1 = fold(args, acc, doAlgTermCountBoundVars);
            if (!isVarBounderOper(name)) acc1 else {
                v = cast(args[0] : AlgTerm -> AlgTermVarUse);
                setTree(acc1, v, lookupTreeDef(acc, v, 0) + 1);
            }
        }
    }
}
