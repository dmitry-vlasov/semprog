import eval;
import dynamic;
import common_types;
import math/math;

export {
    // Integer operations
    makeIntConst(name : string, val : int) -> EvalOper;
    makeIntUnary(name : string, op : (int) -> int) -> EvalOper;
    makeIntBinary(name : string, op : (int, int) -> int) -> EvalOper;

    intOpers : [EvalOper];
    intConst : EvalConst;
}

intOpers = [
    makeIntUnary("-", \x -> -x),
    makeIntBinary("+", \x, y -> x + y),
    makeIntBinary("*", \x, y -> x * y),
    makeIntBinary("/", \x, y -> x / y),
    makeIntBinary("-", \x, y -> x - y)
];

intConst = EvalConst(
    intType, 
    \n -> if (isDigits(n)) {
        flow(s2i(n));
    } else {
        println("wrong integer format: " + n);
        flow(undefVal);
    }
);

makeIntConst(name : string, val : int) -> EvalOper {
    EvalOper(name,
        funcAlgType([], intType),
        \e, args, vals -> {
            if (length(args) != 0) flow(undefVal) else {
                flow(val);
            }
        },
        showConstEvalOper(name)
    )
}

makeIntUnary(name : string, op : (int) -> int) -> EvalOper {
    EvalOper(name, 
        funcAlgType([intType], intType),
        \e, args, vals -> {
            if (length(args) != 1) flow(undefVal) else {
                flow(op(flow2i(e.eval(args[0], vals))));
            }
        },
        showUnaryEvalOper(name)
    )
}

makeIntBinary(name : string, op : (int, int) -> int) -> EvalOper {
    EvalOper(name, 
        funcAlgType([intType, intType], intType),
        \e, args, vals -> {
            if (length(args) != 2) flow(undefVal) else {
                flow(op(
                    flow2i(e.eval(args[0], vals)), 
                    flow2i(e.eval(args[1], vals))
                ));
            }
        },
        showBinaryEvalOper(name)
    );
}
