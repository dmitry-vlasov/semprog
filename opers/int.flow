import eval;
import dynamic;
import common_types;
import math/math;

export {
    // Integer operations
    makeIntConst(name : string, val : int) -> EvalOper;
    makeIntUnary(name : string, op : (int) -> int) -> EvalOper;
    makeIntBinary(name : string, op : (int, int) -> int) -> EvalOper;

    intOpers : [EvalOper];
    intConst : EvalConst;
}

// evalAlgTerms(e : Eval, terms : [AlgTerm], vals : Tree<string, flow>, acc : flow) -> flow

intOpers = [
    makeIntUnary("-", \x -> -x),
    EvalOper("+",
        funcAlgType([variadicAlgType(intType)], intType),
        \e, args, vals -> {
            arg_vals = evalAlgTerms(e, args, vals, []);
            if (arg_vals == undefVal) flow(undefVal) else {
                flow(fold(
                    map(cast(arg_vals : flow -> [flow]), flow2i), 0, \acc, i -> acc + i
                ));
            }
        },
        showVariadicEvalOper("+")
    ),
    EvalOper("*",
        funcAlgType([variadicAlgType(intType)], intType),
        \e, args, vals -> {
            arg_vals = evalAlgTerms(e, args, vals, []);
            if (arg_vals == undefVal) flow(undefVal) else {
                flow(fold(
                    map(cast(arg_vals : flow -> [flow]), flow2i), 1, \acc, i -> acc * i
                ));
            }
        },
        showVariadicEvalOper("*")
    ),
    makeIntBinary("/", \x, y -> x / y),
    makeIntBinary("-", \x, y -> x - y)
];

intConst = EvalConst(
    intType, 
    \n -> if (isDigits(n)) {
        flow(s2i(n));
    } else {
        println("wrong integer format: " + n);
        flow(undefVal);
    }
);

makeIntConst(name : string, val : int) -> EvalOper {
    EvalOper(name,
        funcAlgType([], intType),
        \e, args, vals -> {
            if (length(args) != 0) flow(undefVal) else {
                flow(val);
            }
        },
        showConstEvalOper(name)
    )
}

makeIntUnary(name : string, op : (int) -> int) -> EvalOper {
    EvalOper(name, 
        funcAlgType([intType], intType),
        \e, args, vals -> {
            if (length(args) != 1) flow(undefVal) else {
                arg_val = e.eval(args[0], vals);
                if (arg_val == undefVal) flow(undefVal) else {
                    flow(op(flow2i(arg_val)));
                }
            }
        },
        showUnaryEvalOper(name)
    )
}

makeIntBinary(name : string, op : (int, int) -> int) -> EvalOper {
    EvalOper(name, 
        funcAlgType([intType, intType], intType),
        \e, args, vals -> {
            if (length(args) != 2) flow(undefVal) else {
                arg1_val = e.eval(args[0], vals);
                if (arg1_val == undefVal) flow(undefVal) else {
                    arg2_val = e.eval(args[1], vals);
                    if (arg2_val == undefVal) flow(undefVal) else {
                        flow(op(flow2i(arg1_val), flow2i(arg2_val)));
                    }
                }
            }
        },
        showBinaryEvalOper(name)
    );
}
