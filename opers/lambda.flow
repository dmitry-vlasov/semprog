import shower;
import dynamic;

export {
    // Recursion, lambda and conditional operators
    makeIf(type : AlgType) -> EvalOper;
    makeLambda(var_type : AlgType, val_type : AlgType) -> EvalOper;
    makeRecursion(n : AlgType, arg_types : [AlgType], val : AlgType) -> EvalOper;
}

makeIf(type : AlgType) -> EvalOper {
    EvalOper(
        "if", funcAlgType([boolType, type, type], type),
        \args -> Eval(\vals, conf -> 
            if (length(args) != 3) flow(undefVal) else {
                if (flow2b(args[0].eval(vals, conf))) {
                    args[1].eval(vals, conf);
                } else {
                    args[2].eval(vals, conf);
                }
            }
        ),
        \args -> Show(\conf ->
            if (length(args) != 3) "broken term" else
            "(if " + args[0].show(conf) + " then " + args[1].show(conf) + " else " + args[2].show(conf) + ")"
        )
    );
}

makeLambda(var_type : AlgType, body : AlgType) -> EvalOper {
    EvalOper(
        "lambda", 
        funcAlgType([var_type], funcAlgType([var_type], val_type)),
        \args -> Eval(\vals, conf -> {
            v = flow2s(args[0].eval(vals, conf));
            \x -> args[0].eval(setTree(vals, v, x), conf)
        }),
        \args -> Show(\conf ->
            "lambda " + args[0].show(conf) + " : " + algType2s(var_type) + " " + args[0].show(conf)
        )
    );
}

doRecursion(
    f_0 : ([flow]) -> flow,
    f_1 : ([flow]) -> flow,
    g : ([flow]) -> flow,
    p : ([flow]) -> flow,
    args : [flow]
) -> flow {
    if (flow2b(p(args))) f_0(args) else {
        f_1(concat(
            [doRecursion(f_0, f_1, g, p, 
                concat([g(args)], tail(args))
            )],
            args
        ));
    }
}

recursion(
    f_0 : ([flow]) -> flow,
    f_1 : ([flow]) -> flow,
    g : ([flow]) -> flow,
    p : ([flow]) -> flow
) -> ([flow]) -> flow {
    \args -> doRecursion(f_0, f_1, g, p, args);
}

makeRecursion(n : AlgType, arg_types : [AlgType], val : AlgType) -> EvalOper {
    EvalOper("rec", 
        funcAlgType(
            [
                funcAlgType(concat([n], arg_types), val),       // f_0
                funcAlgType(concat([val, n], arg_types), val),  // f_1
                funcAlgType(concat([n], arg_types), n),         // g
                funcAlgType(concat([n], arg_types), boolType),  // p
            ],
            funcAlgType(concat([n], arg_types), val)
        ),
        \args -> Eval(\vals, conf -> {
            f_0 = cast(args[0].eval(vals, conf): flow -> ([flow]) -> flow);
            f_1 = cast(args[1].eval(vals, conf): flow -> ([flow]) -> flow);
            g   = cast(args[2].eval(vals, conf): flow -> ([flow]) -> flow);
            p   = cast(args[3].eval(vals, conf): flow -> ([flow]) -> flow);
            recursion(f_0, f_1, g, p);
        }),
        showDfEvalOper("rec")
    );
}

