

def n_m_k__win_strategy(n : int, m : int, k : int) : bool {
	let a_steps : [tuple(int, int)] = arr[];
	let b_steps : [tuple(int, int)] = arr[];
	n_m_k__win_strategy(n, m, k, a_steps, b_steps, 0)
}

def n_m_k__win_strategy(
	n : int, 
	m : int, 
	k : int, 
	a_steps : [tuple(int, int)],
	b_steps : [tuple(int, int)],
	step : int
) : bool {
	let a_win : bool = check_is_winning(n, m, k, a_steps);
	let b_win : bool = check_is_winning(n, m, k, b_steps);
	let show_pos : (tuple(int, int)) -> string = lambda(pair : tuple(int, int), 
		("[" + i2s(first(pair)) + "," + i2s(second(pair)) + "]")
	);
	let show_n_m_k : string = (i2s(n) + "-" + i2s(m) + "-" + i2s(k));
	let show_moves : string = (
		"X moves: " + 
		fold(a_steps, "", lambda(acc : string, pair : tuple(int, int),
				(acc + show_pos(pair) + ", ")
			)
		) + "\n" +
		"O moves: " + 
		fold(b_steps, "", lambda(acc : string, pair : tuple(int, int),
				(acc + show_pos(pair) + ", ")
			)
		) + "\n"
	);
	if(
		seq(
			/*println((
				/*show_moves + 
				if(
					(step = 0), "",
					let pair : tuple(int, int) = get(a_steps, 0);
					("a_steps contains: " + show_pos(pair) + ": " + b2s(contains(a_steps, get(a_steps, 0))) + "\n")
				) +* /
				if(a_win, "X wins " + show_n_m_k + " game\n", if(b_win, "O wins\n", "No wins\n")) + 
				show_board(n, m, a_steps, b_steps)
			)),*/
			println(
				if(a_win, 
					("X wins " + show_n_m_k + " game\n" + show_moves + 
						show_board(n, m, a_steps, b_steps)
					), 
					if(b_win, 
						("O wins " + show_n_m_k + " game\n" + show_moves + 
							show_board(n, m, a_steps, b_steps)
						), 
						""
					)
				)
			),
			(a_win /\ !(b_win))
		),
		true,
		if(
			b_win,
			false,
			if (
				(step = k),
				false,
				E(ax : int, [0 ... (n - 1)],
					E(ay : int, [0 ... (m - 1)],
						let a : tuple(int, int) = makeTuple(ax, ay);
						(
							!(contains(a_steps, a)) /\
							!(contains(b_steps, a)) /\
							let a1_steps : [tuple(int, int)] = add(a_steps, a);
							if(
								check_is_winning(n, m, k, a1_steps),
								true,
								A(bx : int, [0 ... (n - 1)],
									A(by : int, [0 ... (m - 1)],
										let b : tuple(int, int) = makeTuple(bx, by);
										(
											(!(contains(a1_steps, b)) /\ !(contains(b_steps, b))) ->
											let b1_steps : [tuple(int, int)] = add(b_steps, b);
											n_m_k__win_strategy(n, m, k, a1_steps, b1_steps, (step + 1))
										)
									)
								)
							)
						)
					)
				)
			)
		)
	)
}

def check_is_winning_fn(
	n : int, 
	m : int, 
	k : int, 
	steps : [tuple(int, int)], 
	fn : (int, int, int) -> tuple(int, int)
) : bool {
	E(i : int, [0 ... (n - 1)],
		E(j : int, [0 ... (m - 1)],
			A(s : int, [0 ... (k - 1)],
				contains(steps, fn(i, j, s))
			)
		)
	)
}

def check_is_winning(
	n : int, 
	m : int, 
	k : int, 
	steps : [tuple(int, int)]
) : bool {
	(
		check_is_winning_fn(n, m, k, steps,
			lambda(i : int, j : int, s : int,
				makeTuple(i, (j + s))
			)
		) \/
		check_is_winning_fn(n, m, k, steps,
			lambda(i : int, j : int, s : int,
				makeTuple((i + s), j)
			)
		) \/
		check_is_winning_fn(n, m, k, steps,
			lambda(i : int, j : int, s : int,
				makeTuple((i + s), (j + s))
			)
		)
	)
}

def show_board(
	n : int, 
	m : int, 
	a_steps : [tuple(int, int)],
	b_steps : [tuple(int, int)],
) : string {
	let show_pos : (int, int) -> string = lambda(i : int, j : int
		let pos : tuple(int, int) = makeTuple(i, j);
		if(contains(a_steps, pos), "X", if(contains(b_steps, pos), "O", "_"))
	);
	let show_row : (int) -> string = lambda(i : int,
		fold([0 ... (m - 1)], "", 
			lambda(acc : string, j : int,
				(acc + show_pos(i, j))
			)
		)
	);
	let str : string = fold([0 ... (n - 1)], "",
		lambda(acc : string, i : int,
			let s : string = show_row(i);
			(acc + "\n" + s)
		)
	);
	("board:\n" + str + "\n")
}

def main() : void {
    println(
		("n_m_k: 1x1x1: \n\t" + 
			a2s(n_m_k__win_strategy(1, 1, 1))
		),
		("n_m_k: 2x2x2: \n\t" + 
			a2s(n_m_k__win_strategy(2, 2, 2))
		),
		("n_m_k: 3x3x3: \n\t" + 
			a2s(n_m_k__win_strategy(3, 3, 3))
		),
		("n_m_k: 4x4x3: \n\t" + 
			a2s(n_m_k__win_strategy(4, 4, 3))
		),
		("n_m_k: 5x5x3: \n\t" + 
			a2s(n_m_k__win_strategy(5, 5, 3))
		)
    )
}

