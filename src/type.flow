import ds/tree;
import ds/set;
import string;

export {
    // General algebraic types: type variables and type constructors.
    AlgType ::= AlgTypeVar, AlgTypeFunc;

    // Type variable (polymorphic) - a variable for a type.
    AlgTypeVar(name : string);

    // General form of an algebraic type: a function on types.
    AlgTypeFunc(
        name : string, 
        args : [AlgType]
    );

	// Special universal type: anything
    anyType = constAlgType("any");

	// Special types for reflection.
	termType = constAlgType("term");
	typeType = constAlgType("type");

    algType2s(type : AlgType) -> string;

    // -- A set of common algebraic type operators -- 

    // Basic types like 'int', 'bool', 'float', etc.
    constAlgType(name : string) -> AlgTypeFunc;

    // Array (sequence) type: [type]
    arrayAlgType(type : AlgType) -> AlgTypeFunc;

    // Functional type: (arg_1, ... , arg_k) -> val
    funcAlgType(args : [AlgType], val : AlgType) -> AlgTypeFunc;

    // Union type: (type_1 U type_2 U ... U type_k)
    unionAlgType(args : [AlgType]) -> AlgTypeFunc;

	// Tuple type: (type_1, type_2, ... , type_k)
    //tupleAlgType(args : [AlgType]) -> AlgTypeFunc;

    // Product type: (type_1 x type_2 x ... x type_k)
    prodAlgType(args : [AlgType]) -> AlgTypeFunc;

    // Variadic type: () or (type) or (type, type) or ... (type, ... , type)
    variadicAlgType(arg : AlgType) -> AlgTypeFunc;

    // Function type: args and value
    funcArgTypes(fn : AlgTypeFunc) -> [AlgType];
    funcValType(fn : AlgTypeFunc) -> AlgType;

    // Make an n-ary function over a type 
    makeFuncType(n : int, type : AlgType) -> AlgTypeFunc;

    // un-array type
    unwrapArrayAlgType(type : AlgType) -> AlgType;

    // A special constant - undefined type.
    undefType : AlgType = AlgTypeFunc("__undef_type", []);

    // Substitute type variables with approptiate values from 'sub'
    instantiateType(tp : AlgType, sub : Tree<string, AlgType>) -> AlgType;

    // Match a left with a type: try to instantiate type variables properly
    matchType(left : AlgType, right : AlgType, ac : Tree<string, AlgType>) -> Maybe<Tree<string, AlgType>>;

    // Matching a left with respect to variadic type 
    matchTypes(left : [AlgType], right : [AlgType], ac : Tree<string, AlgType>) -> Maybe<Tree<string, AlgType>>;
}

algType2s(type : AlgType) -> string {
    switch (type) {
        AlgTypeVar(name): name;
        AlgTypeFunc(name, args): {
            if (name == "ar") "[" + (if (length(args) == 0) "" else algType2s(args[0])) + "]" else 
            if (name == "fn") "(" + strGlue(map(tail(args), algType2s), ", ") + ") -> " + (if (length(args) == 0) "" else algType2s(args[0])) else
            if (name == "U")  "(" + strGlue(map(args, algType2s), "U") + ")" else
            if (name == "x")  "(" + strGlue(map(args, algType2s), "x") + ")" else
			if (name == "tp") "(" + strGlue(map(args, algType2s), ", ") + ")" else
            if (name == "...") { if (length(args) == 0) "..." else algType2s(args[0]) + ", ... ," + algType2s(args[0]) } else 
			name + (if (length(args) == 0) "" else "(" + strGlue(map(args, algType2s), ", ") + ")");
        }
    }
}

constAlgType(name : string) -> AlgTypeFunc {
    AlgTypeFunc(name, []);
}

arrayAlgType(type : AlgType) -> AlgTypeFunc {
    AlgTypeFunc("ar", [type]);
}

funcAlgType(args : [AlgType], val : AlgType) -> AlgTypeFunc {
    AlgTypeFunc("fn", concat([val], args));
}

unionAlgType(args : [AlgType]) -> AlgTypeFunc {
    AlgTypeFunc("U", args);
}

/*tupleAlgType(args : [AlgType]) -> AlgTypeFunc {
    AlgTypeFunc("tp", args);
}*/

prodAlgType(args : [AlgType]) -> AlgTypeFunc {
    AlgTypeFunc("X", args);
}

variadicAlgType(arg : AlgType) -> AlgTypeFunc {
    AlgTypeFunc("...", [arg]);
}

funcArgTypes(fn : AlgTypeFunc) -> [AlgType] {
    if (fn.name != "fn") [undefType] else tail(fn.args);
}

funcValType(fn : AlgTypeFunc) -> AlgType {
    if (fn.name != "fn") undefType else fn.args[0];
}

makeFuncType(n : int, type : AlgType) -> AlgTypeFunc {
    funcAlgType(map(enumFromTo(0, n - 1), \__ -> type), type);
}

unwrapArrayAlgType(type : AlgType) -> AlgType {
    switch (type) {
        AlgTypeVar(__): undefType;
        AlgTypeFunc(name, args): {
            if (name == "ar" && length(args) == 1) args[0] else undefType;
        }
    }
}

instantiateType(tp : AlgType, sub : Tree<string, AlgType>) -> AlgType {
    switch (tp) {
        AlgTypeVar(v): lookupTreeDef(sub, v, tp);
        AlgTypeFunc(__, as): {
            AlgTypeFunc(tp with args = map(as, \a -> instantiateType(a, sub)));
        }
    }
}

matchType(left0 : AlgType, right0 : AlgType, ac : Tree<string, AlgType>) -> Maybe<Tree<string, AlgType>> {
	left = instantiateType(left0, ac);
	right = instantiateType(right0, ac);
    ret = switch (left) {
        AlgTypeVar(left_v): {
            switch (lookupTree(ac, left_v)) {
                Some(left_t): {
					maybeMap(matchType(left_t, right, ac), 
						\ac1 -> {
							resolved = instantiateType(right, ac1);
							setTree(ac1, left_v, resolved);
						}
					);
					/*if (t == right) Some(ac) else 
					if (t != anyType) None() else {
						Some(setTree(ac, v, right));
					}*/
				}
                None(): {
					Some(setTree(ac, left_v, right));
				}
            }
        }
        AlgTypeFunc(left_name, left_args): {
            switch (right) {
                AlgTypeVar(right_v): {
					switch (lookupTree(ac, right_v)) {
						Some(right_t): {
							maybeMap(matchType(left, right_t, ac), 
								\ac1 -> {
									resolved = instantiateType(left, ac1);
									setTree(ac1, right_v, resolved);
								}
							);
							/*if (t == right) Some(ac) else 
							if (t != anyType) None() else {
								Some(setTree(ac, v, right));
							}*/
						}
						None(): Some(setTree(ac, right_v, right));
					}
				}
                AlgTypeFunc(right_name, right_args): {
                    if (left_name == right_name) {
						matchTypes(left_args, right_args, ac);
					} else if (left_name == "any" || right_name == "any") {
						// any is a universal type
						Some(ac);
					} else {
						None();
					}
                }
            }
        }
    }
    /*println(
        "(A) matching: " + algType2s(left) + 
        " with: " + algType2s(right) + 
        " ret: " + toString(ret)
    );*/
    ret;
}

unwrapVariadicAlgType(type : AlgType) -> AlgType {
    switch (type) {
        AlgTypeVar(__): undefType;
        AlgTypeFunc(name, args): {
            if (name == "..." && length(args) == 1) {
                args[0];
            } else {
                undefType;
            }
        }
    }
}

matchTypes(lefts : [AlgType], rights : [AlgType], acc : Tree<string, AlgType>) -> Maybe<Tree<string, AlgType>> {

    ret = if (length(lefts) == 0) {
        if (length(rights) == 0) {
            Some(acc);
        } else {
            None();
        }
    } else {
		variadic_left = unwrapVariadicAlgType(lefts[0]);
		if (variadic_left == undefType) {
			if (length(rights) == 0) {
				None();
			} else if (length(lefts) == length(rights)) {
				maybeBind(
					matchType(lefts[0], rights[0], acc),
					\sub -> matchTypes(tail(lefts), tail(rights), sub)
				);
			} else {
				None();
			}
		} else {
			if (length(rights) == 0) {
				Some(acc);
			} else {
				//println("variafic left: " + algType2s(variadic_left));
				maybeBind(
					matchType(variadic_left, rights[0], acc),
					\sub -> {
						variadic_type = instantiateType(variadic_left, sub);
						//println("variadic_type: " + algType2s(variadic_type));
						matchVariadicTypes(variadic_type, tail(lefts), tail(rights), sub);
					}
				);
			}
		}
    }

    /*println(
        "(B) matching: " + strGlue(map(lefts, algType2s), ", ") + 
        " with: " + strGlue(map(rights, algType2s), ", ") + 
        " ret: " + toString(ret)
    );*/
    ret;
}

matchVariadicTypes(variadic : AlgType, lefts : [AlgType], rights : [AlgType], acc : Tree<string, AlgType>) -> Maybe<Tree<string, AlgType>> {
    if (length(rights) == 0) {
        Some(acc);
    } else {
        if (rights[0] == variadic) {
            matchVariadicTypes(variadic, lefts, tail(rights), acc);
        } else {
            matchTypes(lefts, rights, acc);
        }
    }
}
