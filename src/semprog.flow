import net/url_parameter;
import fs/filesystem;
import parser/parse;
import typecheck;
import module;
import evaluator;
import algebra;

main() -> void {
    println("Semantic programming framework\n");
	conf = makeConf();
	if (conf.file == "") {
		println("No input file.");
	} else if (!fileExists(conf.file)) {
        println("File: " + conf.file  + " doesn't exist");
    } else {
        ext = getFileExt(conf.file);
        if (ext != ".sem") {
            println("Extension: " + ext  + " mismatches the expected .sem");
        } else {
            src = getFileContent(conf.file);
            name = changeFileExt(conf.file, "");
			parsed = parseModule(src, name);
			if (lookupTreeDef(conf.opts, "show-parsed", "") == "1") {
            	println("Parsed module " + name + ":\n" + moduleTerms2s(parsed, conf) + "\n\n");
			} 
            module = typecheckModule(parsed, fullAlgebra);

            algebra = EvalAlgebra("module " + name + " algebra", 
                fold(module.defs, fullAlgebra.opers, \acc, def -> 
                    concat(acc, [makeDefOper(def)])
                ),
                fullAlgebra.consts
            );
			semantics := algebraEval(algebra);
			shower := algebraShow(algebra);

			if (lookupTreeDef(conf.opts, "show-algebra", "") == "1") {
				println(evalAlgebra2s(algebra));
			} else if (lookupTreeDef(conf.opts, "show-module", "") == "1") {
            	println("Module " + name + ":\n" + module2s(module, conf) + "\n\n");
			} else {
            	^semantics(AlgTermFunc("main", [], voidType)).eval(conf.opts, conf);
            	{}
			}
        }
    }
    quit(0);
}
