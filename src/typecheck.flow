import term;

export {
    typecheckTerm(term : AlgTerm, vars : Tree<string, AlgType>, signs : Tree<string, [AlgTypeFunc]>) -> AlgTerm;
}

typecheckTerm(term : AlgTerm, vars : Tree<string, AlgType>, signs : Tree<string, [AlgTypeFunc]>) -> AlgTerm {
    //println("(A) typechecking: " + toString(term) + " ...");
    //println("(B) typechecking: " + algTerm2s(term) + " ...");
    ret = switch (term) {
        AlgTermVarUse(name, type): {
			resolved = lookupTreeDef(vars, name, type);
			if (resolved == undefType) {
				println("UNDEF RESOLVED TYPE FOR: " + algTerm2s(term));
			}
            AlgTermVarUse(term with type = resolved);
        }
        AlgTermVarDecl(name, type): {
			if (type == undefType) {
				println("UNDEF DECLARED TYPE FOR: " + algTerm2s(term));
			}
            term;
        }
        AlgTermFunc(name, args, type): {
            typed_args = fold(args, Pair([], vars), \acc, arg -> {
                typed = typecheckTerm(arg, acc.second, signs);
                Pair(
                    concat(acc.first, [typed]),
                    switch (arg) {
                        AlgTermVarDecl(nm, tp): setTree(acc.second, nm, typed.type);
                        default: acc.second;
                    }
                );
            })
			arg_types = map(typed_args.first, \arg -> arg.type);
			find_val_type = \ops, def_type -> {
				fits = filtermap(ops, \op -> 
					maybeMap(
						matchTypes(funcArgTypes(op), arg_types, makeTree()),
						\sub -> Pair(op, sub)
					)
				);
				if (length(fits) == 0) {
					if (def_type == undefType) {
						println("(B) no operator " + name + " matches argument types:\n" + 
							strIndent(strGlue(map(arg_types, \t -> algType2s(t)), "\n"))
						);
						println("ops:\n" + 
							strIndent(strGlue(map(ops, \op -> algType2s(op)), "\n"))
						);
						println("term: " + algTerm2s(term));
					}
					def_type;
				} else if (length(fits) > 1) {
					println("ambigous operator " + name + " matching with argument types: " + strGlue(map(arg_types, \t -> algType2s(t)), ", "));
					def_type;
				} else {
					op = fits[0].first;
					sub = fits[0].second;
					if (op.name != "fn") {
						println("NOT fn: " + op.name);
						def_type 
					} else {
						ret = instantiateType(funcValType(op), sub);
						if (ret == undefType) {
							println("NOT typechecked: instantiateType(funcValType(op), sub) failed\n\t" + algTerm2s(term));
						}
						ret;
					}
				}
			}
			surrender = \msg-> {
				if (type == undefType) {
					println("Surrender: " + msg + " unknown operator: " + name);
				}
				type
			}
            val_type = {
                if (exists(arg_types, \t -> t == undefType)) {
                    println(
						"untyped: " + name + ": " + strGlue(map(arg_types, algType2s), ", ") + "\n" +
						"\t" + algTerm2s(term)
					);
                    undefType;
                } else {
					switch (lookupTree(signs, name))  {
						Some(ops): find_val_type(ops, type);
						None(): {
							switch (lookupTree(typed_args.second, name)) {
								Some(var_type): {
									switch (var_type) {
										AlgTypeFunc(__,__): find_val_type([var_type], type);
										default: surrender("A_");
									}
								} 
								None(): surrender("B_");
							}
						}
					};
				}
			}
            AlgTermFunc(term with 
                type = val_type,
                args = typed_args.first
            );
        }
    }
	if (ret.type == undefType) {
    	println("NOT typechecked: " + algTerm2s(term) + " : " + algType2s(ret.type));
	}
    ret
}
