import ds/tree;
import ds/set;
import string;

export {
    // General algebraic types: variables and type constructors.
    Type ::= TypeVar, TypeFunc;
    TypeVar(name : string);
    TypeFunc(
        name : string, 
        args : [Type], 
        show : ((Type)-> string, [Type]) -> string
    );

    type2s(type : Type) -> string;

    // A set of common algebraic type operators
    constType(name : string) -> TypeFunc;
    arType(type : Type) -> TypeFunc;
    fnType(args : [Type], val : Type) -> TypeFunc;
    unType(args : [Type]) -> TypeFunc;
    prType(args : [Type]) -> TypeFunc;
    nAryType(arg : Type) -> TypeFunc;

    // Function type: args and value
    fnArgTypes(fn : TypeFunc) -> [Type];
    fnValType(fn : TypeFunc) -> Type;

    // un-array type
    unArType(type : Type) -> Type;

    // A special constant - undefined type.
    undefType = TypeFunc("", [], \__,__ -> "undef_type");

    // Common const type: boolean
    boolType = constType("bool");
    naryBoolFnType(n : int) -> TypeFunc;
    unaryBoolFnType = naryBoolFnType(1);
    binaryBoolFnType = naryBoolFnType(2);

    // Common const type: integer
    intType = constType("int");
    naryIntFnType(n : int) -> TypeFunc;
    unaryIntFnType = naryIntFnType(1);
    binaryIntFnType = naryIntFnType(2);

    instantiateType(tp : Type, sub : Tree<string, Type>) -> Type;
    matchType(pattern : Type, tp : Type, ac : Tree<string, Type>) -> Maybe<Tree<string, Type>>;
    matchTypes(pattern : [Type], tp : [Type], ac : Tree<string, Type>) -> Maybe<Tree<string, Type>>;
}

type2s(type : Type) -> string {
    switch (type) {
        TypeVar(name): name;
        TypeFunc(__, args, show): show(type2s, args);
    }
}

showFnType(show : (Type) -> string, args : [Type]) -> string {
    "(" + strGlue(map(tail(args), show), ", ") + ") -> " + show(args[0]);
}

showArType(show : (Type) -> string, args : [Type]) -> string {
    "[" + show(args[0]) + "]";
}

showPrType(show : (Type) -> string, args : [Type]) -> string {
    strGlue(map(args, show), "X");
}

showUnType(show : (Type) -> string, args : [Type]) -> string {
    strGlue(map(args, show), "U");
}

showDfType(name : string) -> (show : (Type) -> string, args : [Type]) -> string {
    \show, args -> {
        name + (if (length(args) == 0) "" else  "(" + strGlue(map(args, show), ", ") + ")");
    }
}


constType(name : string) -> TypeFunc {
    TypeFunc(name, [], \__,__ -> name);
}

arType(type : Type) -> TypeFunc {
    TypeFunc("ar", [type], \show, args -> "[" + show(args[0]) + "]");
}

fnType(args : [Type], val : Type) -> TypeFunc {
    TypeFunc(
        "fn", 
        concat([val], args), 
        \show, as -> "(" + strGlue(map(tail(as), show), ", ") + ") -> " + show(as[0])
    );
}

unType(args : [Type]) -> TypeFunc {
    TypeFunc("U", args, \show, as -> strGlue(map(as, show), "U"));
}

prType(args : [Type]) -> TypeFunc {
    TypeFunc("X", args, \show, as -> strGlue(map(as, show), "X"));
}

nAryType(arg : Type) -> TypeFunc {
    TypeFunc(
        "...", [arg], 
        \show, args -> show(args[0]) + " ... " + show(args[0])
    );
}

naryBoolFnType(n : int) -> TypeFunc {
    fnType(map(enumFromTo(0, n - 1), \__ -> boolType), boolType);
}

naryIntFnType(n : int) -> TypeFunc {
    fnType(map(enumFromTo(0, n - 1), \__ -> intType), intType);
}

fnArgTypes(fn : TypeFunc) -> [Type] {
    if (fn.name != "fn") [undefType] else tail(fn.args);
}

fnValType(fn : TypeFunc) -> Type {
    if (fn.name != "fn") undefType else fn.args[0];
}

unArType(type : Type) -> Type {
    switch (type) {
        TypeVar(__): undefType;
        TypeFunc(name, args, __): {
            if (name == "ar" && length(args) == 1) args[0] else undefType;
        }
    }
}

instantiateType(tp : Type, sub : Tree<string, Type>) -> Type {
    switch (tp) {
        TypeVar(v): lookupTreeDef(sub, v, tp);
        TypeFunc(__, as, __): {
            TypeFunc(tp with args = map(as, \a -> instantiateType(a, sub)));
        }
    }
}

matchType(pattern : Type, tp : Type, ac : Tree<string, Type>) -> Maybe<Tree<string, Type>> {
    switch (pattern) {
        TypeVar(v): {
            switch (lookupTree(ac, v)) {
                Some(t): if (t == tp) Some(ac) else None();
                None(): Some(setTree(ac, v, tp));
            }
        }
        TypeFunc(name, args, __): {
            switch (tp) {
                TypeVar(__): None();
                TypeFunc(n, as, __): {
                    if (name != n) {
                        if (name != "...") None() else {
                            if (length(as) == 0) Some(ac) else {
                                maybeBind(
                                    matchType(args[0], as[0], ac),
                                    \sub -> {
                                        t_1 = instantiateType(args[0], sub);
                                        if (forall(as, \a -> a == t_1)) {
                                            Some(sub);
                                        } else {
                                            None();
                                        }
                                    }
                                );
                            }
                        }
                    } else if (length(args) != length(as)) {
                        None();
                    } else {
                        fold(
                            zipWith(args, as, \x, y -> Pair(x, y)), 
                            Some(ac), 
                            \a, p -> maybeBind(a, \sub -> matchType(p.first, p.second, sub))
                        );
                    }
                }
            }
        }
    }
}

MatchTypesEnv(
    sub : Tree<string, Type>,
    i : int,
    j : int
);

matchTypes(pattern : [Type], tp : [Type], ac : Tree<string, Type>) -> Maybe<Tree<string, Type>> {
    fold(pattern, MatchTypesEnv(ac, 0, 0), 

    )
    fold(
        zipWith(args, as, \x, y -> Pair(x, y)), 
                            Some(ac), 
                            \a, p -> maybeBind(a, \sub -> matchType(p.first, p.second, sub))
                        );

    switch (pattern) {
        TypeVar(v): {
            switch (lookupTree(ac, v)) {
                Some(t): if (t == tp) Some(ac) else None();
                None(): Some(setTree(ac, v, tp));
            }
        }
        TypeFunc(name, args, __): {
            switch (tp) {
                TypeVar(__): None();
                TypeFunc(n, as, __): {
                    if (name != n) {
                        if (name != "...") None() else {
                            if (length(as) == 0) Some(ac) else {
                                maybeBind(
                                    matchType(args[0], as[0], ac),
                                    \sub -> {
                                        t_1 = instantiateType(args[0], sub);
                                        if (forall(as, \a -> a == t_1)) {
                                            Some(sub);
                                        } else {
                                            None();
                                        }
                                    }
                                );
                            }
                        }
                    } else if (length(args) != length(as)) {
                        None();
                    } else {
                        fold(
                            zipWith(args, as, \x, y -> Pair(x, y)), 
                            Some(ac), 
                            \a, p -> maybeBind(a, \sub -> matchType(p.first, p.second, sub))
                        );
                    }
                }
            }
        }
    }
}