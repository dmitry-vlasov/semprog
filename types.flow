import ds/tree;
import ds/set;
import string;

export {
    // General algebraic types: variables and type constructors.
    Type ::= TypeVar, TypeFunc;
    TypeVar(name : string);
    TypeFunc(
        name : string, 
        args : [Type], 
        show : ((Type)-> string, [Type]) -> string
    );

    type2s(type : Type) -> string;

    // A set of common algebraic type operators
    constType(name : string) -> TypeFunc;
    arType(type : Type) -> TypeFunc;
    fnType(args : [Type], val : Type) -> TypeFunc;
    unType(args : [Type]) -> TypeFunc;
    prType(args : [Type]) -> TypeFunc;

    // A special constant - undefined type.
    undefType = TypeFunc("", [], \__,__ -> "undef_type");

    // Common const type: boolean
    boolType = constType("bool");
    naryBoolFnType(n : int) -> TypeFunc;
    unaryBoolFnType = naryBoolFnType(1);
    binaryBoolFnType = naryBoolFnType(2);

    // Common const type: integer
    intType = constType("int");
    naryIntFnType(n : int) -> TypeFunc;
    unaryIntFnType = naryIntFnType(1);
    binaryIntFnType = naryIntFnType(2);
}

type2s(type : Type) -> string {
    switch (type) {
        TypeVar(name): name;
        TypeFunc(__, args, show): show(type2s, args);
    }
}

showFnType(show : (Type) -> string, args : [Type]) -> string {
    "(" + strGlue(map(tail(args), show), ", ") + ") -> " + show(args[0]);
}

showArType(show : (Type) -> string, args : [Type]) -> string {
    "[" + show(args[0]) + "]";
}

showPrType(show : (Type) -> string, args : [Type]) -> string {
    strGlue(map(args, show), "X");
}

showUnType(show : (Type) -> string, args : [Type]) -> string {
    strGlue(map(args, show), "U");
}

showDfType(name : string) -> (show : (Type) -> string, args : [Type]) -> string {
    \show, args -> {
        name + (if (length(args) == 0) "" else  "(" + strGlue(map(args, show), ", ") + ")");
    }
}


constType(name : string) -> TypeFunc {
    TypeFunc(name, [], \__,__ -> name);
}

arType(type : Type) -> TypeFunc {
    TypeFunc("ar", [type], showArType);
}

fnType(args : [Type], val : Type) -> TypeFunc {
    TypeFunc("fn", concat([val], args), showFnType);
}

unType(args : [Type]) -> TypeFunc {
    TypeFunc("U", args, showUnType);
}

prType(args : [Type]) -> TypeFunc {
    TypeFunc("X", args, showPrType);
}

naryBoolFnType(n : int) -> TypeFunc {
    fnType(map(enumFromTo(0, n - 1), \__ -> boolType), boolType);
}

naryIntFnType(n : int) -> TypeFunc {
    fnType(map(enumFromTo(0, n - 1), \__ -> intType), intType);
}