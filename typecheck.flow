import term;

export {
    typecheck(term : AlgTerm, vars : Tree<string, AlgType>, signs : Tree<string, [AlgTypeFunc]>) -> AlgTerm;
}

typecheck(term : AlgTerm, vars : Tree<string, AlgType>, signs : Tree<string, [AlgTypeFunc]>) -> AlgTerm {
    //println("(A) typechecking: " + toString(term) + " ...");
    //println("(B) typechecking: " + algTerm2s(term) + " ...");
    ret = switch (term) {
        AlgTermVar(name, __): {
            AlgTermVar(term with type = lookupTreeDef(vars, name, undefAlgType));
        }
        AlgTermVarDecl(name, type): {
            term;
        }
        AlgTermFunc(name, args, type): {
            typed_args = fold(args, Pair([], vars), \acc, arg -> {
                typed = typecheck(arg, acc.second, signs);
                Pair(
                    concat(acc.first, [typed]),
                    switch (arg) {
                        AlgTermVarDecl(nm, tp): setTree(acc.second, nm, typed.type);
                        default: acc.second;
                    }
                );
            }).first;
            arg_types = map(typed_args, \arg -> arg.type);
            val_type = 
                if (exists(arg_types, \t -> t == undefAlgType)) {
                    println("untyped: " + name + ": " + strGlue(map(arg_types, algType2s), ", ") );
                    undefAlgType;
                } else 
                eitherMap(lookupTree(signs, name), 
                    \ops -> {
                        fits = filtermap(ops, \op -> 
                            maybeMap(
                                matchTypes(funcArgTypes(op), arg_types, makeTree()),
                                \sub -> Pair(op, sub)
                            )
                        );
                        if (length(fits) == 0) {
                            println("(B) no operator " + name + " matches argument types: " + strGlue(map(arg_types, \t -> algType2s(t)), ", "));
                            println("ops: " + strGlue(map(ops, \op -> algType2s(op)), ", "));
                            println("term: " + algTerm2s(term));
                            undefAlgType;
                        } else if (length(fits) > 1) {
                            println("ambigous operator " + name + " matching with argument types: " + strGlue(map(arg_types, \t -> algType2s(t)), ", "));
                            undefAlgType;
                        } else {
                            op = fits[0].first;
                            sub = fits[0].second;
                            if (op.name != "fn") undefAlgType else
                            instantiateType(funcValType(op), sub);
                        }
                    }, type
                );
            AlgTermFunc(term with 
                type = val_type,
                args = typed_args
            );
        }
    }
    //println("DONE typechecked: " + algTerm2s(term) + " : " + algType2s(ret.type));
    ret
}
