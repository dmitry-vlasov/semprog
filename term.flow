import types;

export {
    // General form of an algebraic term: variable or an operation over other terms.
    AlgTerm ::= AlgTermVar, AlgTermFunc;
    AlgTermVar(name : string, type : Type);
    AlgTermFunc(name : string, args : [AlgTerm], type : Type);

    algTerm2s(term : AlgTerm) -> string;
    algTypedTerm2s(term : AlgTerm) -> string;
    algTerm2vars(term : AlgTerm) -> Set<AlgTermVar>;
    undefTerm = AlgTermVar("UNDEF", undefType);

    // standard classes of operations

    // /\, \/, !, <->, ->
    isBoolOper(name : string) -> bool;

    // A, E, BA, BE, S
    isQuantifierOper(name : string) -> bool;
}

algTerm2s(term : AlgTerm) -> string {
    switch (term) {
        AlgTermVar(name, type): name;
        AlgTermFunc(name, args, type): {
            if (length(args) == 0) name else {
                    name + "(" + strGlue(map(args, algTerm2s), ", ") + ")";
            }
        }
    }
}

algTypedTerm2s(term : AlgTerm) -> string {
    switch (term) {
        AlgTermVar(name, type): name + " : " + type2s(type);
        AlgTermFunc(name, args, type): {
            if (length(args) == 0) name else {
                    name + " : " + type2s(type) +  " (" + strGlue(map(args, algTypedTerm2s), ", ") + ")";
            }
        }
    }
}

algTerm2vars(term : AlgTerm) -> Set<AlgTermVar> {
    doAlgTerm2s(makeSet(), term);
}

doAlgTerm2s(acc : Set<AlgTermVar>, term : AlgTerm) -> Set<AlgTermVar> {
    switch (term) {
        AlgTermVar(__, __): insertSet(acc, term);
        AlgTermFunc(__, args, __): fold(args, acc, doAlgTerm2s);
    }
}

isBoolOper(name : string) -> bool {
    startsWith(name, "\\/") || startsWith(name, "/\\") || name == "!" || name == "->" || name == "<->";
}

isQuantifierOper(name : string) -> bool {
    startsWith(name, "A ") || startsWith(name, "E ") || startsWith(name, "BA ") || startsWith(name, "BE ") || startsWith(name, "S ") || startsWith(name, "\\ ");
}