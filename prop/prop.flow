import eval;
import dynamic;
import math/math;

export {
    // The definition of semantics for a classical propositional logic.
    makeBoolConst(name : string, v : bool) -> EvalOper;
    boolTrue = makeBoolConst("T", true);
    boolFalse = makeBoolConst("F", false);

    makeBoolUnary(name : string, op : (bool) -> bool) -> EvalOper;
    lnot = makeBoolUnary("!", \v -> !v);

    makeBoolBinary(name : string, op : (bool, bool) -> bool) -> EvalOper;
    lor = makeBoolBinary("\\/", \v1, v2 -> v1 || v2);
    land = makeBoolBinary("/\\", \v1, v2 -> v1 && v2);
    limpl = makeBoolBinary("->", \v1, v2 -> !v1 || v2);
    leq = makeBoolBinary("<->", \v1, v2 -> (v1 && v2) || (!v1 && !v2));
    
    propLogic = EvalAlgebra("propositioal logic", [boolTrue, boolFalse, lnot, land, limpl, leq, lor]);

    // QBF algebra
    makeBoolQuantifier(BQ : string, v : string) -> EvalOper;
    makeQBFAlgebra(vars : [string]) -> EvalAlgebra;
    getBoolQuantifiers(f : AlgTerm) -> [string];

    // Propositional logic with n-ary conjunctions and disjunctions
    makeBoolNary(name : string, arity : int, op: ([bool]) -> bool) -> EvalOper;
    makeLongOr(arity : int) -> EvalOper;
    makeLongAnd(arity : int) -> EvalOper;
    makeLongPropLogicAlgebra(lens : [int]) -> EvalAlgebra;
    getLongLogOpers(f : AlgTerm) -> [int];

    makeLongOperation(name : string, args : [AlgTerm]) -> AlgTermFunc;

    makeQBFLongAlgebra(vars : [string], lens : [int]) -> EvalAlgebra;
}

// General boolean operators

makeBoolConst(name : string, v : bool) -> EvalOper {
    EvalOper(name, boolType, 
        \__, args, __ -> {
            if (length(args) != 0) flow(undefVal) else flow(v)
        },
        \__,__ -> name
    );
}

makeBoolUnary(name : string, op : (bool) -> bool) -> EvalOper {
    EvalOper(name, unaryBoolFnType, 
        \e, args, vals -> {
            if (length(args) != 1) flow(undefVal) else {
                flow(op(flow2b(e.eval(args[0], vals))));
            }
        },
        showUnaryEvalOper(name)
    )
}

makeBoolBinary(name : string, op : (bool, bool) -> bool) -> EvalOper {
    EvalOper(name, binaryBoolFnType,
        \e, args, vals -> {
            if (length(args) != 2) flow(undefVal) else {
                flow(op(
                    flow2b(e.eval(args[0], vals)), 
                    flow2b(e.eval(args[1], vals))
                ));
            }
        },
        showBinaryEvalOper(name)
    );
}


// QBF stuff

makeQBFAlgebra(vars : [string]) -> EvalAlgebra {
    EvalAlgebra("QBF logic", 
        concat3(
            propLogic.opers, 
            map(vars, \v -> makeBoolQuantifier("BA", v)), 
            map(vars, \v -> makeBoolQuantifier("BE", v))  
        )
    );
}

makeBoolQuantifier(BQ : string, v : string) -> EvalOper {
    EvalOper(BQ + " " + v,
        fnType([boolType] , boolType),
        \e, args, vals -> {
            if (length(args) != 2) {
                flow(undefVal)
            } else {
                if (BQ == "BA") {
                    flow( 
                        flow2b(e.eval(args[1], setTree(vals, v, true))) 
                        && 
                        flow2b(e.eval(args[1], setTree(vals, v, false)))
                        );
                } else {
                    flow( 
                        flow2b(e.eval(args[1], setTree(vals, v, true))) 
                        || 
                        flow2b(e.eval(args[1], setTree(vals, v, false)))
                        );
                }
            }
        },
        \s, args -> {
            if (length(args) != 2) "broken term" else
            BQ + " " + v + " " + s.show(args[1]);
        }
    ); 
}

getBoolQuantifiers(f : AlgTerm) -> [string] {
    vs = doGetBoolQuantifiers(makeSet(), f);
    set2array (mapSet(vs, \v -> v.name))
}

doGetBoolQuantifiers(acc : Set<AlgTermVar>, f : AlgTerm) -> Set<AlgTermVar> {
   switch (f) {
        AlgTermVar(var, type): acc;
        AlgTermFunc(op, args, type): {
            if (!(startsWith(op, "BA ") || startsWith(op, "BE "))) {
                fold(args, acc, doGetBoolQuantifiers);
            } else {
                if (length(args) == 0) acc else {
                    v = args[0];
                    switch (v) {
                        AlgTermVar(__,__): 
                            fold(tail(args), insertSet(acc, v), doGetBoolQuantifiers);
                        AlgTermFunc(__,__,__): 
                            fold(args, acc, doGetBoolQuantifiers);
                    }
                }
            }
        }
   } 
}

// Long /\ and \/ stuff

makeBoolNary(name : string, arity : int, op: ([bool]) -> bool) -> EvalOper {
    EvalOper(name + "-" + i2s(arity), 
        naryBoolFnType(arity),
        \e, args, vals -> {
            if (length(args) != arity) flow(undefVal) else {
                flow(op(map(args, \arg -> flow2b(e.eval(arg, vals)))));
            }
        },
        showNaryEvalOper(name, arity)
    );
}

makeLongOr(arity : int) -> EvalOper {
    makeBoolNary("\\/", arity, any);
}

makeLongAnd(arity : int) -> EvalOper {
    makeBoolNary("/\\", arity, all);
}

makeLongPropLogicAlgebra(lens : [int]) -> EvalAlgebra {
    EvalAlgebra("Prop logic with long /\\ and \\/", 
        concat3(
            propLogic.opers, 
            map(lens, \len -> makeLongOr(len)), 
            map(lens, \len -> makeLongAnd(len))  
        )
    );
}

getLongLogOpers(f : AlgTerm) -> [int] {
     set2array(doGetLongLogOpers(makeSet(), f));
}

doGetLongLogOpers(acc : Set<int>, f : AlgTerm) -> Set<int> {
   switch (f) {
        AlgTermVar(var, type): acc;
        AlgTermFunc(op, args, type): {
            if (!(startsWith(op, "/\\-") || startsWith(op, "\\/-"))) {
                fold(args, acc, doGetLongLogOpers);
            } else {
                fold(args, insertSet(acc, length(args)), doGetLongLogOpers);
            }
        }
   } 
}

makeLongOperation(name : string, args : [AlgTerm]) -> AlgTermFunc {
    AlgTermFunc(name + "-" + i2s(length(args)), args, boolType);
}

makeQBFLongAlgebra(vars : [string], lens : [int]) -> EvalAlgebra {
    qbf_algebra = makeQBFAlgebra(vars);
    long_algebra = makeLongPropLogicAlgebra(lens);
    EvalAlgebra("QBFLongAlgebra", concat(qbf_algebra.opers, long_algebra.opers));
}