import eval;
import dynamic;

export {
    // Basic first order logic construcitons: restricted quantifier, equality and predicates.
    makeQuantifier(Q : string, v : string, t : Type, quant : ([?], (?) -> bool) -> bool) -> EvalOper;
    makeEquality(t : Type) -> EvalOper ;
    makeNotEquality(t : Type) -> EvalOper ;
    makePredicate(name : string, types : [Type], p : ([flow]) -> bool) -> EvalOper;
    makeFilter(v : string, t : Type) -> EvalOper;

    makeForallTerm(v : AlgTermVar, t : AlgTerm, phi : AlgTerm) -> AlgTermFunc;
    makeExistsTerm(v : AlgTermVar, t : AlgTerm, phi : AlgTerm) -> AlgTermFunc;

    algTerm2freeVars(t : AlgTerm) -> Set<AlgTermVar>;
    algTerm2boundVars(t : AlgTerm) -> Set<AlgTermVar>;
    algTermCountBoundVars(t : AlgTerm) -> Tree<AlgTermVar, int>;
}

makeQuantifier(Q : string, v : string, t : Type, quant : ([?], (?) -> bool) -> bool) -> EvalOper {
    EvalOper(Q + " " + v,
        fnType([arType(t), boolType] , boolType),
        \e, args, vals -> {
            if (length(args) != 3) {
                flow(undefVal)
            } else {
                flow(quant(
                    cast(e.eval(args[1], vals) : flow -> [flow]),
                    \a -> flow2b(e.eval(args[2], setTree(vals, v, a)))
                ));
            }
        },
        \s, args -> {
            if (length(args) != 3) "broken term" else
            Q + " " + v + " : " + s.show(args[1]) + " " + s.show(args[2]);
        }
    ); 
}

makeFilter(v : string, t : Type) -> EvalOper {
    EvalOper("S " + v,
        fnType([arType(t), boolType] , arType(t)),
        \e, args, vals -> {
            if (length(args) != 3) {
                flow(undefVal)
            } else {
                flow(filter(
                    cast(e.eval(args[1], vals) : flow -> [flow]),
                    \a -> flow2b(e.eval(args[2], setTree(vals, v, a)))
                ));
            }
        },
        \s, args -> {
            if (length(args) != 3) "broken term" else
            "S " + v + " : " + s.show(args[1]) + " " + s.show(args[2]);
        }
    ); 
}

makeEquality(t : Type) -> EvalOper {
    EvalOper("=", 
        fnType([t, t] , boolType),
        \e, args, vals -> {
            if (length(args) != 2) flow(undefVal) else {
                flow(e.eval(args[0], vals) == e.eval(args[1], vals));
            }
        },
        showBinaryEvalOper("=")
    );
}

makeNotEquality(t : Type) -> EvalOper {
    EvalOper("!=", 
        fnType([t, t] , boolType),
        \e, args, vals -> {
            if (length(args) != 2) flow(undefVal) else {
                flow(e.eval(args[0], vals) != e.eval(args[1], vals));
            }
        },
        showBinaryEvalOper("!=")
    );
}

makePredicate(name : string, types : [Type], p : ([flow]) -> bool) -> EvalOper {
    EvalOper(name, fnType(types, boolType),
        \e, args, vals -> {
            if (length(args) != length(types)) flow(undefVal) else {
                flow(p(map(args, \arg -> e.eval(arg, vals))))
            }
        },
        showDfEvalOper(name)
    );
}

makeForallTerm(v : AlgTermVar, t : AlgTerm, phi : AlgTerm) -> AlgTermFunc {
    AlgTermFunc("A " + v.name, [v, t, phi], boolType);
}

makeExistsTerm(v : AlgTermVar, t : AlgTerm, phi : AlgTerm) -> AlgTermFunc {
    AlgTermFunc("E " + v.name, [v, t, phi], boolType);
}

algTerm2freeVars(t : AlgTerm) -> Set<AlgTermVar> {
    doAlgTerm2freeVars(makeSet(), t);
}

doAlgTerm2freeVars(acc : Set<AlgTermVar>, t : AlgTerm) -> Set<AlgTermVar> {
    switch (t) {
        AlgTermVar(__,__): insertSet(acc, t);
        AlgTermFunc(name, args, __): {
            acc1 = fold(args, acc, doAlgTerm2freeVars);
            if (!isVarBounderOper(name)) acc1 else {
                removeSet(acc1, cast(args[0] : AlgTerm -> AlgTermVar));
            }
        }
    }
}

algTerm2boundVars(t : AlgTerm) -> Set<AlgTermVar> {
    free = algTerm2freeVars(t);
    all = algTerm2vars(t);
    differenceSets(all, free);
}

algTermCountBoundVars(t : AlgTerm) -> Tree<AlgTermVar, int> {
    doAlgTermCountBoundVars(makeTree(), t);
}

doAlgTermCountBoundVars(acc : Tree<AlgTermVar, int>, t : AlgTerm) -> Tree<AlgTermVar, int> {
    switch (t) {
        AlgTermVar(__,__): acc; // setTree(acc, t, lookupTreeDef(acc, t, 0) + 1);
        AlgTermFunc(name, args, __): {
            acc1 = fold(args, acc, doAlgTermCountBoundVars);
            if (!isVarBounderOper(name)) acc1 else {
                v = cast(args[0] : AlgTerm -> AlgTermVar);
                setTree(acc1, v, lookupTreeDef(acc, v, 0) + 1);
            }
        }
    }
}