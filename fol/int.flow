import eval;
import dynamic;

export {
    // Integer operations
    makeIntConst(name : string, val : int) -> EvalOper;
    makeIntUnary(name : string, op : (int) -> int) -> EvalOper;
    makeIntBinary(name : string, op : (int, int) -> int) -> EvalOper;

    intInv = makeIntUnary("-", \x -> -x);
    intAdd = makeIntBinary("+", \x, y -> x + y);
    intProd = makeIntBinary("*", \x, y -> x * y);
    intDiv = makeIntBinary("/", \x, y -> x / y);
    intSub = makeIntBinary("-", \x, y -> x - y);

    intZero = makeIntConst("0", 0);
    intOne = makeIntConst("1", 1);
    intTwo = makeIntConst("2", 2);
}

makeIntConst(name : string, val : int) -> EvalOper {
    EvalOper(name, intType, 
        \e, args, vals -> {
            if (length(args) != 0) flow(undefVal) else {
                val;
            }
        },
        showConstEvalOper(name)
    )
}

makeIntUnary(name : string, op : (int) -> int) -> EvalOper {
    EvalOper(name, unaryIntFnType, 
        \e, args, vals -> {
            if (length(args) != 1) flow(undefVal) else {
                op(flow2i(e.eval(args[0], vals)));
            }
        },
        showUnaryEvalOper(name)
    )
}

makeIntBinary(name : string, op : (int, int) -> int) -> EvalOper {
    EvalOper(name, binaryIntFnType,
        \e, args, vals -> {
            if (length(args) != 2) flow(undefVal) else {
                op(flow2i(e.eval(args[0], vals)), flow2i(e.eval(args[1], vals)));
            }
        },
        showBinaryEvalOper(name)
    );
}