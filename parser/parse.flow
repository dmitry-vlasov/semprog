import lingo/pegcode/driver;
import module;
import common_types;

export {
    parseModule(str : string, name : string) -> Module;
}

parseModule(str : string, name : string) -> Module {
    e_gr = "#include parser/module.lingo";
	parsic(compilePegGrammar(e_gr), str, 
        SemanticActions(
            mergeTree(defaultPegActions.t,
            pairs2tree([
                Pair("makeModule", \s -> Module(name, cast(s[0] : flow -> [Def]))),
                Pair("makeDef", \s -> Def(flow2s(s[0]), s[1], s[2], s[3])),
                Pair("makeTypedVar", \s -> TypedVar(flow2s(s[0]), s[1])),
                Pair("makeTypeConst", \s -> constAlgType(flow2s(s[0]))),
                Pair("makeTypeArray", \s -> arrayAlgType(s[0])),
                Pair("makeTypeFn", \s -> funcAlgType(s[0], s[1])),
                Pair("makeTypeProd", \s -> prodAlgType(s[0])),
                Pair("makeTypeUnion", \s -> unionAlgType(s[0])),

                Pair("makeTermFunc", \s -> {
                    //println("makeBoolFunc: " + flow2s(s[0]) + " = " + toString(s));
                    args = tail(s);
                    id = flow2s(s[0]);
                    if (length(args) > 0) {
                        AlgTermFunc(id, args, undefAlgType);
                    } else if (isDigits(id)) {
                        AlgTermFunc(id, [], intType);
                    } else {
                        AlgTermFunc(id, [], stringType);
                    }
                }),
                Pair("makeTermFuncNary", \s -> {
                    id = flow2s(s[0]);
                    args = cast(s[1] : flow -> [flow]);
                    AlgTermFunc(id, args, undefAlgType);
                }),
                Pair("makeTermFuncNary1", \s -> {
                    id = flow2s(s[0]);
                    arg = s[1];
                    args = cast(s[2] : flow -> [flow]);
                    AlgTermFunc(id, concat([arg], args), undefAlgType);
                }),
                Pair("makeTermVar",  \s -> {
                    //println("makeIntVar: " + flow2s(s[0]) + " = " + toString(s));
                    AlgTermVar(flow2s(s[0]), undefAlgType)
                }),
                Pair("makeArray", \s -> {
                    //println("makeArray: " + flow2s(s[0]) + " = " + toString(s));
                    //println(s[1]);
                    AlgTermFunc("array", s[1], undefAlgType)
                }),
                Pair("makeQuantifier", \s -> { 
                    //println(s[1]);
                    var = cast(s[1] : flow -> AlgTermVar);
                    //println("makeQuantifier: " + flow2s(s[0]) + " " + var.name + " = " + toString(s));
                    AlgTermFunc(flow2s(s[0]) + " " + var.name, tail(s), undefAlgType)
                }),
                Pair("makeArrFromTo", \s -> { 
                    //println("makeArrFromTo: " + flow2s(s[0]) + " = " + toString(s));
                    AlgTermFunc(flow2s(s[0]), tail(s), undefAlgType)
                }),
            ]))
        )
    );
}